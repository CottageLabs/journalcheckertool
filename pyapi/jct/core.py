import os
import json
import elasticsearch

from flask import Flask
from flask_cors import CORS

from jct import settings
from jct.lib import paths, dates, es_data_mapping

def create_app():
    """
    ~~CreateApp:Framework->Flask:Technology~~
    :return:
    """
    app = Flask(__name__)
    configure_app(app)
    setup_jinja(app)
    CORS(app)
    initialise_apm(app)
    proxyfix(app)
    return app


##################################################
# Configure the App

def configure_app(app):
    """
    Configure from:
     a) the settings.py file
     b) the <env>.cfg file
     c) the local secrets config in app.cfg
     d) the ansible-generated instance config

    instance.cfg is generated by ansible script (server_initial_setup.yml from sysadmin repo)

    Later imports have precedence, so e.g. instance.cfg override app.cfg, app.cfg will override the same setting
    in production.cfg and settings.py.
    """

    # import for settings.py
    app.config.from_object(settings)

    # import from <env>.cfg
    proj_root = paths.get_project_root().as_posix()
    app.config['JCTENV'] = get_app_env(app)
    config_path = os.path.join(proj_root, app.config['JCTENV'] + '.cfg')
    print('Running in ' + app.config['JCTENV'])  # the app.logger is not set up yet (?)
    if os.path.exists(config_path):
        app.config.from_pyfile(config_path)
        print('Loaded environment config from ' + config_path)

    # import from app.cfg
    config_path = os.path.join(proj_root, 'app.cfg')
    if os.path.exists(config_path):
        app.config.from_pyfile(config_path)
        print('Loaded secrets config from ' + config_path)

    # import from instance.cfg
    instance_path = os.path.join(proj_root, 'instance.cfg')
    if os.path.exists(instance_path):
        app.config.from_pyfile(instance_path)
        print('Loaded instance specific config from ' + instance_path)


def get_app_env(app):
    if not app.config.get('VALID_ENVIRONMENTS'):
        raise Exception('VALID_ENVIRONMENTS must be set in the config. There shouldn\'t be a reason to change it in different set ups, or not have it.')

    env = os.getenv('JCTENV')
    if not env:
        envpath = paths.rel2abs(__file__, '../.env')
        if os.path.exists(envpath):
            with open(envpath, 'r') as f:
                env = f.readline().strip()

    if not env or env not in app.config['VALID_ENVIRONMENTS']:
        raise Exception(
"""
Set the JCTENV environment variable when running the app, guessing is futile and fraught with peril.
JCTENV=test python portality/app.py
to run the app will do.
Or use the supervisord options - put this in the config: environment= JCTENV="test" .

Finally, you can create a file called .env with the text e.g. 'dev' in the root of the repo.
Recommended only for dev environments so you don't have to bother specifying it each time you run a script or test.

Valid values are: {valid_env_vals}

You can put environment-specific secret settings in <environment>.cfg , e.g. dev.cfg .

The environment specified in the JCTENV environment variable will override that specified in the
application configuration (settings.py or app.cfg).
""".format(valid_env_vals=', '.join(app.config['VALID_ENVIRONMENTS']))
        )
    return env


############################################
# Elasticsearch initialisation

def create_es_connection(app):
    # ~~ElasticConnection:Framework->Elasticsearch:Technology~~

    conn = elasticsearch.Elasticsearch(app.config['ELASTICSEARCH_HOSTS'],
                                       verify_certs=app.config.get("ELASTIC_SEARCH_VERIFY_CERTS", True),
                                       timeout=app.config.get('ELASTICSEARCH_REQ_TIMEOUT', 15))
    return conn


def prepare_type(es_type):
    """ Ensure a type has an index correctly prepared - e.g. LCC on app startup """
    expected_alias = app.config['ELASTIC_SEARCH_DB_PREFIX'] + es_type

    if not es_connection.indices.exists(expected_alias):
        initialise_index(app, es_connection, only_mappings=es_type)


def put_mappings(conn, mappings, force_mappings=False):

    for key, mapping in iter(mappings.items()):
        altered_key = app.config['ELASTIC_SEARCH_DB_PREFIX'] + key

        # If the alias exists, we don't automatically create any new indices (app already initialised)
        if conn.indices.exists(altered_key):
            if force_mappings:
                r = conn.indices.put_mapping(index=altered_key, body=mapping.get("mappings"), request_timeout=app.config.get("ES_SOCKET_TIMEOUT", None))
                print("Updating mapping via alias {0} for {1}; status: {2}".format(altered_key, key, r))
            else:
                print("Alias {0} already exists for type {1}".format(altered_key, key))
        else:
            print("Preparing new index / alias for " + key)
            # Set up a new index and corresponding alias
            idx_name = altered_key + '-{}'.format(dates.today(dates.FMT_DATE_SHORT))

            try:
                resp = es_connection.indices.create(index=idx_name,
                                                    body=mapping,
                                                    request_timeout=app.config.get("ES_SOCKET_TIMEOUT", None))
                print("Initialised index: {}".format(resp['index']))
            except elasticsearch.exceptions.RequestError as e:
                print('Could not create index: ' + str(e))

            resp2 = es_connection.indices.put_alias(index=idx_name, name=altered_key)
            print("Created alias:     {:<25} -> {},  status {}".format(idx_name, altered_key, resp2))


def initialise_index(app, conn, only_mappings=None, force_mappings=False):
    """
    ~~InitialiseIndex:Framework->Elasticsearch:Technology~~
    :param app:
    :param conn:
    :param only_mappings: Init a subset of the index types
    :param force_mappings: Put the mapping to an index that already exists
    :return:
    """
    if not app.config['INITIALISE_INDEX']:
        app.logger.warning('INITIALISE_INDEX config var is not True, initialise_index command cannot run')
        return

    if app.config.get("READ_ONLY_MODE", False) and app.config.get("SCRIPTS_READ_ONLY_MODE", False):
        app.logger.warning("System is in READ-ONLY mode, initialise_index command cannot run")
        return

    # get the app mappings
    mappings = es_data_mapping.get_mappings(app)

    if only_mappings is not None:
        mappings = {key: value for (key, value) in mappings.items() if key in only_mappings}

    # Send the mappings to ES
    put_mappings(conn, mappings, force_mappings)


##################################################
# APM

def initialise_apm(app):
    # if app.config.get('ENABLE_APM', False):
    #     from elasticapm.contrib.flask import ElasticAPM
    #     app.logger.info("Configuring Elastic APM")
    #     apm = ElasticAPM(app, logging=True)
    pass


##################################################
# proxyfix

def proxyfix(app):
    """
    ~~ProxyFix:Framework~~
    :param app:
    :return:
    """
    if app.config.get('PROXIED', False):
        from werkzeug.middleware.proxy_fix import ProxyFix
        app.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)


##################################################
# Jinja2

def setup_jinja(app):
    pass


app = create_app()
es_connection = create_es_connection(app)